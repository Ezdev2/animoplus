import { useQuery, useMutation, useQueryClient } from '@tanstack/vue-query'
import { animalService } from './animalService.js'

// Cl√©s de cache pour les requ√™tes
export const ANIMAL_QUERY_KEYS = {
  all: ['animals'],
  lists: () => [...ANIMAL_QUERY_KEYS.all, 'list'],
  list: (params) => [...ANIMAL_QUERY_KEYS.lists(), params],
  details: () => [...ANIMAL_QUERY_KEYS.all, 'detail'],
  detail: (id) => [...ANIMAL_QUERY_KEYS.details(), id],
  search: (term) => [...ANIMAL_QUERY_KEYS.all, 'search', term],
  byOwner: (ownerId) => [...ANIMAL_QUERY_KEYS.all, 'owner', ownerId],
  bySpecies: (speciesId) => [...ANIMAL_QUERY_KEYS.all, 'species', speciesId]
}

/**
 * Hook pour r√©cup√©rer la liste des animaux avec pagination
 * @param {Object} params - Param√®tres de requ√™te
 * @param {Object} options - Options de la requ√™te
 * @returns {Object} R√©sultat de la requ√™te TanStack Query
 */
export function useAnimals(params = {}, options = {}) {
  return useQuery({
    queryKey: ANIMAL_QUERY_KEYS.list(params),
    queryFn: () => animalService.getAnimals(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    keepPreviousData: true, // Garde les donn√©es pr√©c√©dentes pendant le chargement
    ...options
  })
}

/**
 * Hook pour r√©cup√©rer un animal sp√©cifique
 * @param {number} id - ID de l'animal
 * @param {Object} includeOptions - Options d'inclusion des relations
 * @param {Object} options - Options de la requ√™te
 * @returns {Object} R√©sultat de la requ√™te TanStack Query
 */
export function useAnimal(id, includeOptions = {}, options = {}) {
  return useQuery({
    queryKey: ANIMAL_QUERY_KEYS.detail(id),
    queryFn: () => animalService.getAnimalById(id, includeOptions),
    enabled: !!id, // Ne lance la requ√™te que si l'ID existe
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    ...options
  })
}

/**
 * Hook pour rechercher des animaux
 * @param {string} searchTerm - Terme de recherche
 * @param {Object} searchOptions - Options de recherche
 * @param {Object} options - Options de la requ√™te
 * @returns {Object} R√©sultat de la requ√™te TanStack Query
 */
export function useSearchAnimals(searchTerm, searchOptions = {}, options = {}) {
  return useQuery({
    queryKey: ANIMAL_QUERY_KEYS.search(searchTerm),
    queryFn: () => animalService.searchAnimals(searchTerm, searchOptions),
    enabled: !!searchTerm && searchTerm.length >= 2, // Recherche √† partir de 2 caract√®res
    staleTime: 2 * 60 * 1000, // 2 minutes pour les recherches
    cacheTime: 5 * 60 * 1000, // 5 minutes
    ...options
  })
}

/**
 * Hook pour r√©cup√©rer les animaux d'un propri√©taire
 * @param {number} ownerId - ID du propri√©taire
 * @param {Object} queryOptions - Options de requ√™te
 * @param {Object} options - Options de la requ√™te
 * @returns {Object} R√©sultat de la requ√™te TanStack Query
 */
export function useAnimalsByOwner(ownerId, queryOptions = {}, options = {}) {
  return useQuery({
    queryKey: ANIMAL_QUERY_KEYS.byOwner(ownerId),
    queryFn: () => animalService.getAnimalsByOwner(ownerId, queryOptions),
    enabled: !!ownerId,
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    ...options
  })
}

/**
 * Hook pour r√©cup√©rer les animaux par esp√®ce
 * @param {number} speciesId - ID de l'esp√®ce
 * @param {Object} queryOptions - Options de requ√™te
 * @param {Object} options - Options de la requ√™te
 * @returns {Object} R√©sultat de la requ√™te TanStack Query
 */
export function useAnimalsBySpecies(speciesId, queryOptions = {}, options = {}) {
  return useQuery({
    queryKey: ANIMAL_QUERY_KEYS.bySpecies(speciesId),
    queryFn: () => animalService.getAnimalsBySpecies(speciesId, queryOptions),
    enabled: !!speciesId,
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    ...options
  })
}

/**
 * Hook pour cr√©er un animal
 * @param {Object} options - Options de la mutation
 * @returns {Object} Mutation TanStack Query
 */
export function useCreateAnimal(options = {}) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (animalData) => animalService.createAnimal(animalData),
    onSuccess: (data, variables) => {
      // Invalider les listes d'animaux pour forcer le rechargement
      queryClient.invalidateQueries({ queryKey: ANIMAL_QUERY_KEYS.lists() })
      
      // Si on conna√Æt le propri√©taire, invalider sa liste d'animaux
      if (variables.proprietaire_id) {
        queryClient.invalidateQueries({ 
          queryKey: ANIMAL_QUERY_KEYS.byOwner(variables.proprietaire_id) 
        })
      }
      
      // Si on conna√Æt l'esp√®ce, invalider sa liste d'animaux
      if (variables.espece_id) {
        queryClient.invalidateQueries({ 
          queryKey: ANIMAL_QUERY_KEYS.bySpecies(variables.espece_id) 
        })
      }
    },
    ...options
  })
}

/**
 * Hook pour mettre √† jour un animal
 * @param {Object} options - Options de la mutation
 * @returns {Object} Mutation TanStack Query
 */
export function useUpdateAnimal(options = {}) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, data }) => animalService.updateAnimal(id, data),
    onSuccess: (data, variables) => {
      const { id } = variables
      
      // Mettre √† jour le cache de l'animal sp√©cifique
      queryClient.setQueryData(ANIMAL_QUERY_KEYS.detail(id), data)
      
      // Invalider et refetch imm√©diatement les listes pour refl√©ter les changements
      queryClient.invalidateQueries({ 
        queryKey: ANIMAL_QUERY_KEYS.lists(),
        refetchType: 'active' // Force le refetch des requ√™tes actives
      })
      queryClient.invalidateQueries({ 
        queryKey: ANIMAL_QUERY_KEYS.all,
        refetchType: 'active'
      })
      
      // Invalider aussi les requ√™tes par propri√©taire si on a l'info
      if (data?.data?.proprietaire_id) {
        queryClient.invalidateQueries({ 
          queryKey: ANIMAL_QUERY_KEYS.byOwner(data.data.proprietaire_id),
          refetchType: 'active'
        })
      }
    },
    ...options
  })
}

/**
 * Hook pour supprimer un animal
 * @param {Object} options - Options de la mutation
 * @returns {Object} Mutation TanStack Query
 */
export function useDeleteAnimal(options = {}) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (id) => animalService.deleteAnimal(id),
    onSuccess: (data, id) => {
      console.log('üóëÔ∏è Suppression r√©ussie, mise √† jour du cache pour l\'animal:', id)
      
      // Supprimer l'animal du cache
      queryClient.removeQueries({ queryKey: ANIMAL_QUERY_KEYS.detail(id) })
      
      // Invalider et refetch imm√©diatement toutes les listes d'animaux
      queryClient.invalidateQueries({ 
        queryKey: ANIMAL_QUERY_KEYS.lists(),
        refetchType: 'active'
      })
      queryClient.invalidateQueries({ 
        queryKey: ANIMAL_QUERY_KEYS.all,
        refetchType: 'active'
      })
      
      // Invalider aussi les requ√™tes par propri√©taire
      queryClient.invalidateQueries({ 
        queryKey: ANIMAL_QUERY_KEYS.byOwner,
        refetchType: 'active'
      })
      
      console.log('‚úÖ Cache invalid√©, les listes vont se mettre √† jour')
    },
    ...options
  })
}

/**
 * Hook pour uploader une photo d'animal
 * @param {Object} options - Options de la mutation
 * @returns {Object} Mutation TanStack Query
 */
export function useUploadAnimalPhoto(options = {}) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: ({ id, file }) => animalService.uploadAnimalPhoto(id, file),
    onSuccess: (data, variables) => {
      const { id } = variables
      
      // Invalider le cache de l'animal pour r√©cup√©rer la nouvelle photo
      queryClient.invalidateQueries({ queryKey: ANIMAL_QUERY_KEYS.detail(id) })
      
      // Invalider les listes pour mettre √† jour les miniatures
      queryClient.invalidateQueries({ queryKey: ANIMAL_QUERY_KEYS.lists() })
    },
    ...options
  })
}

/**
 * Hook compos√© pour la gestion compl√®te d'un animal
 * Combine r√©cup√©ration, mise √† jour et suppression
 * @param {number} id - ID de l'animal
 * @returns {Object} Objet avec toutes les op√©rations disponibles
 */
export function useAnimalManagement(id) {
  const queryClient = useQueryClient()

  const animalQuery = useAnimal(id, { 
    with_espece: true, 
    with_race: true, 
    with_proprietaire: true 
  })

  const updateMutation = useUpdateAnimal({
    onSuccess: () => {
      // Notification de succ√®s (√† impl√©menter selon votre syst√®me de notifications)
      console.log('Animal mis √† jour avec succ√®s')
    },
    onError: (error) => {
      console.error('Erreur lors de la mise √† jour:', error)
    }
  })

  const deleteMutation = useDeleteAnimal({
    onSuccess: () => {
      console.log('Animal supprim√© avec succ√®s')
    },
    onError: (error) => {
      console.error('Erreur lors de la suppression:', error)
    }
  })

  const photoMutation = useUploadAnimalPhoto({
    onSuccess: () => {
      console.log('Photo upload√©e avec succ√®s')
    },
    onError: (error) => {
      console.error('Erreur lors de l\'upload:', error)
    }
  })

  return {
    // Donn√©es
    animal: animalQuery.data?.data,
    isLoading: animalQuery.isLoading,
    isError: animalQuery.isError,
    error: animalQuery.error,
    
    // Actions
    updateAnimal: (data) => updateMutation.mutate({ id, data }),
    deleteAnimal: () => deleteMutation.mutate(id),
    uploadPhoto: (file) => photoMutation.mutate({ id, file }),
    
    // √âtats des mutations
    isUpdating: updateMutation.isLoading,
    isDeleting: deleteMutation.isLoading,
    isUploadingPhoto: photoMutation.isLoading,
    
    // Utilitaires
    refetch: animalQuery.refetch,
    invalidate: () => queryClient.invalidateQueries({ 
      queryKey: ANIMAL_QUERY_KEYS.detail(id) 
    })
  }
}

/**
 * Hook pour pr√©charger un animal
 * Utile pour optimiser les performances lors de la navigation
 * @param {number} id - ID de l'animal √† pr√©charger
 */
export function usePrefetchAnimal(id) {
  const queryClient = useQueryClient()

  return () => {
    queryClient.prefetchQuery({
      queryKey: ANIMAL_QUERY_KEYS.detail(id),
      queryFn: () => animalService.getAnimalById(id, {
        with_espece: true,
        with_race: true,
        with_proprietaire: true
      }),
      staleTime: 5 * 60 * 1000
    })
  }
}
